package cmd

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"github.com/stevenlei/polymer-cli/pkg/api"
	"github.com/stevenlei/polymer-cli/pkg/config"
)

var maxAttempts int
var interval int

// waitCmd represents the wait command
var waitCmd = &cobra.Command{
	Use:   "wait [jobID]",
	Short: "Wait for a proof to be generated",
	Long: `Wait for a proof to be generated by polling the status of the job.

Provide the job ID that was returned when you requested a proof.

Example:
  polymer-cli wait 12345 --max-attempts=30 --interval=5000`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		// Get job ID from arguments
		jobID := args[0]

		// Load configuration
		cfg, err := config.LoadConfig()
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}

		// Validate configuration
		if err := cfg.Validate(); err != nil {
			return err
		}

		// Override config values with command-line flags if provided
		if cmd.Flags().Changed("max-attempts") {
			cfg.MaxAttempts = maxAttempts
		}
		if cmd.Flags().Changed("interval") {
			cfg.Interval = interval
		}

		// Create API client
		client := api.NewClient(cfg.APIKey, cfg.APIURL, cfg.Debug)

		// Wait for proof - only show debug output if debug flag is enabled
		if cfg.Debug {
			fmt.Printf("Waiting for proof with job ID: %s (max %d attempts, %dms interval)...\n",
				jobID, cfg.MaxAttempts, cfg.Interval)
		}

		proofStatus, err := client.WaitForProof(jobID, cfg.MaxAttempts, time.Duration(cfg.Interval)*time.Millisecond)
		if err != nil {
			return fmt.Errorf("failed while waiting for proof: %w", err)
		}

		if cfg.Debug {
			fmt.Println("Proof generated successfully!")
		}

		// Get the raw flag
		returnRaw, err := cmd.Flags().GetBool("raw")
		if err != nil {
			return err
		}

		// Output proof - always use raw in non-debug mode
		if !cfg.Debug || returnRaw {
			// Try to unmarshal if it's a JSON string
			var s string
			if err := json.Unmarshal(proofStatus.Proof, &s); err == nil {
				// It's a JSON string, so use the unquoted value
				fmt.Print(s)
			} else {
				// It's not a JSON string or there was an error
				rawStr := string(proofStatus.Proof)
				if len(rawStr) >= 2 && rawStr[0] == '"' && rawStr[len(rawStr)-1] == '"' {
					rawStr = rawStr[1 : len(rawStr)-1]
				}
				fmt.Print(rawStr)
			}
		} else {
			// Format as pretty JSON (only in debug mode and returnRaw is false)
			var prettyJSON bytes.Buffer
			if err := json.Indent(&prettyJSON, proofStatus.Proof, "", "  "); err != nil {
				return fmt.Errorf("failed to format proof as JSON: %w", err)
			}
			fmt.Println(prettyJSON.String())
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(waitCmd)

	// Optional flags
	waitCmd.Flags().IntVar(&maxAttempts, "max-attempts", 0, "Maximum number of polling attempts (default: value from config)")
	waitCmd.Flags().IntVar(&interval, "interval", 0, "Polling interval in milliseconds (default: value from config)")
	waitCmd.Flags().Bool("raw", false, "Return raw JSON output")
}
